上个例子中response传输的是User对象，显然在一个应用中我们不可能只传输一种类型的数据
由此我们将传输对象抽象成为Object
Rpc需要经过网络传输，有可能失败，类似于Http，引入状态码和状态信息表示服务调用成功还是失败


在上个例子中，我们的Request仅仅只发送了一个id参数过去，这显然是不合理的，
因为在服务端不会只有一个服务一个方法，因此只传递参数服务端不会知道调用哪个方法
因此一个RPC请求中，client发送应该是需要调用的Service接口名，方法名，参数，参数类型
使用Java自带的序列方式（实现接口）


> 即客户端不应该只能对着一个ip端口的一个方法传。


这一版本我们引入了`动态代理`和`反射机制`

**客户端：**
1. 首先，我们看到客户端也调用了UserService接口的方法，所以接口也要在客户端存一份，但是具体实现并不在客户端。
2. UserService proxy = clientProxy.getProxy(UserService.class);这一行很重要，生成一个接口的代理对象，
    为的是该接口对象每次调用方法时会增加一些中间步骤的操作。
3. 该中间步骤获取了调用方法的接口，调用的方法名，对应的参数，对应的参数类型，封装成一个Request，然后发送给服务端。

**服务端：**
1. 解析Request，拿出方法名，参数，参数类型。
2. 服务端中有UserServiceImpl，由该实现类通过反射去调用具体的方法。
3. 把结果封装在Response中，加上状态码，传回给客户端。


总结
> 1. 定义更加通用的消息格式：Request 与Response格式， 从此可能调用不同的方法，与返回各种类型的数据。
> 2. 使用了动态代理进行不同服务方法的Request的封装，
> 3. 客户端更加松耦合，不再与特定的Service，host，port绑定

存在的痛点
> 1. 服务端我们直接绑定的是UserService服务，如果还有其它服务接口暴露呢?（多个服务的注册）
> 2. 服务端以BIO的方式性能是否太低，
> 3. 服务端功能太复杂：监听，处理。需要松耦合