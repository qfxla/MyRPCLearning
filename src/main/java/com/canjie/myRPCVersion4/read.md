本节问题：如何设计并完成自己的协议？
答：自己实现encode与decode


升级过程
在前面的RPC版本中， 我们都是使用的java自带的序列化的方式，事实上使用这种方式性能是很低的
    （序列化后的字节数组， 解码编码速度），而且在netty服务端，我们使用的是netty自带的编码器，
    简单的传输了一个 消息长度（4个字节）| 序列化后的数据 格式的数据。 在这里我们要自定义我们的传输格式和编解码。

下面是我的初步对我的自定义格式的设计了， 先读取消息类型（Requst， Response， ping， pong），
    序列化方式（原生， json，kryo， protobuf..）， 加上消息长度：防止粘包， 再根据长度读取data

消息类型（2Byte）	序列化方式 2Byte	消息长度 4Byte
序列化后的Data….	序列化后的Data…	序列化后的Data….


前提处理： maven pom文件中引入fastjson包， RPCResponse中需要加入DataType字段，
    因为其它序列化方式（json）无法得到Data的类型，



总结
在这版本中，我们自己定义的消息格式，使之支持多种消息类型，序列化方式，使用消息头加长度的方式解决粘包问题

并且，实现了ObjectSerializer与JsonSerializer两种序列化器，也可以轻松扩展为其它序列化方式（实现Serialize接口）。

此版本最大痛点
服务端与客户端通信的host与port预先就必须知道的，每一个客户端都必须知道对应服务的ip与端口号， 并且如果服务挂了或者换地址了，就很麻烦。扩展性也不强
